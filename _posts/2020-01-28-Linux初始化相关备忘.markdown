---
layout: post
title: "Linux初始化相关备忘"
categories: Linux
---
# Linux初始化相关备忘

> 趣谈Linux操作系统备忘

## CPU相关

CPU由计算单元、数据单元、逻辑单元组成。

CPU控制单元包含指令指针寄存器，指令寄存器。指令指针寄存器，存放的是下一条指令在内存中的地址，控制单元不停地将代码段的指令拿进来，先存入指令寄存器。CPU内部还有很多其他的寄存器（通用寄存器，代码段寄存器，栈寄存器，数据段寄存器）。

CPU与设备间的通信通过总线。总线包含数据总线，地址总线。数据总线的位数决定了一次能获取的数据的大小，地址总线的位数决定寻址的范围有多广。

## 程序运行时

程序运行主要是指令+数据。CPU执行程序，需要先加载指令及数据，上面也提到CPU的数据总线和地址总线，那么CPU最终获取指令和数据，都是存放在内存中的，通过内存地址对其加载进CPU的相关寄存器（通用寄存器、指令指针寄存器、指令寄存器等）。程序指令和数据，编译后的可执行文件的文件格式中以代码段，数据段等内容体现。	

## 实模式/保护模式

实模式，保护模式区别在于对于内存地址的计算方式的变更。比如实模式下内存地址是获取CS(代码段寄存器）/DS（数据段寄存器）寄存器的值，左移4位后，加上通用寄存器上的16位偏移量得到。保护模式下内存单独一块区域维护表格形式的段描述符缓存器集合，表格中每项缓存器存储相关段的起始地址，而原来段寄存器存储的值直接为上述表格中的某项，成为段选择子。保护模式下通过先从段寄存器中获取具体某一项，然后再通过这个标识，去表格中获取段的起始地址。

系统一开始启动的时候是实模式的，后续版本需要读取、使用更大内存地址范围的时候，会从实模式切换到保护模式。从实模式切换到保护模式需要做很多工作，大部分工作与内存的访问方式有关，第一项是启用分段，第二项是启用分页。

## CPU运行级别和保护机制

CPU执行代码时，并不会去区分代码是内核代码还是用户代码。CPU与x86架构的特权级别（protection rings）一起来限制用户态程序行为。在任意某个时间点，CPU都运行在某个特定的特权级别，具体表现形式为CPU内有个Current code segment register寄存器保存当前运行的特权级别（数值0~3）。在实模式下，无法实现对I/O、内存等的保护机制，因为CPU是和段寄存器一同配合来实现保护机制的。实模式下段寄存器保存的值是一个内存的起始地址值，而保护模式下的段寄存器保存的值是段描述符表中的某一项，这一项的内容中的相关位包含有运行级别的相关信息。CPU通过比较Current code segment寄存器与Destination code segment寄存器相关运行级别的值，来判定是否可以执行目标代码。

保护模式启用了分段与分页，这是内存保护的基础。基于分页，进程内部维护页表项，将线性的逻辑地址转换为物理地址时可以对内存进行保护，内存页包含相关标识用于实现内存保护机制。

CPU只有通过门描述符来实现特权级别间的切换。门本质是一种电路结构，门结构可以完成电信号之间的各种转换。（具体不清楚，TODO）

## BIOS

计算机加电后，会做一些重置动作，将CS设置为0xFFFFF，将IP设置为0x0000，而x86系统将1M（地址总线20位）空间最上方的0xF0000到0xFFFFF这64k映射给ROM，也就是说加电后的起始访问位置就对应为ROM区域。从这里开始执行，一次加载引导扇区（boot.img)，diskboot.img， lzma_decompress.img，kernel.img顺序启动内核。

## 内核初始化

内核启动初始化，创建0号进程，初始化中断相关，初始化内存系统，初始化文件系统，初始化1号进程（用户进程），切换内核态到用户态。

系统调用通过软中断，中断程序将用户态上下文保存，切换进内核态执行。

